package generate

import (
	"bufio"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"net/http"
	"os"
	"path/filepath"

	"github.com/iancoleman/strcase"

	"github.com/mlflow/mlflow-go/magefiles/generate/discovery"
)

func mkMethodInfoInputPointerType(methodInfo discovery.MethodInfo) *ast.StarExpr {
	return mkStarExpr(mkSelectorExpr(methodInfo.PackageName, methodInfo.Input))
}

// Generate a method declaration on an service interface.
func mkServiceInterfaceMethod(methodInfo discovery.MethodInfo) *ast.Field {
	return &ast.Field{
		Names: []*ast.Ident{ast.NewIdent(strcase.ToCamel(methodInfo.Name))},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					mkNamedField("ctx", mkSelectorExpr("context", "Context")),
					mkNamedField("input", mkMethodInfoInputPointerType(methodInfo)),
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					mkField(mkStarExpr(mkSelectorExpr(methodInfo.PackageName, methodInfo.Output))),
					mkField(mkStarExpr(mkSelectorExpr("contract", "Error"))),
				},
			},
		},
	}
}

// Generate a service interface declaration.
func mkServiceInterfaceNode(
	endpoints map[string]any, interfaceName string, serviceInfo discovery.ServiceInfo,
) *ast.GenDecl {
	// We add one method to validate any of the input structs
	methods := make([]*ast.Field, 0, len(serviceInfo.Methods))

	for _, method := range serviceInfo.Methods {
		if _, ok := endpoints[method.Name]; ok {
			methods = append(methods, mkServiceInterfaceMethod(method))
		}
	}

	// Create an interface declaration
	return &ast.GenDecl{
		Tok: token.TYPE, // Specifies a type declaration
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(interfaceName),
				Type: &ast.InterfaceType{
					Methods: &ast.FieldList{
						List: methods,
					},
				},
			},
		},
	}
}

func saveASTToFile(fset *token.FileSet, file *ast.File, addComment bool, outputPath string) error {
	// Create or truncate the output file
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outputFile.Close()

	// Use a bufio.Writer for buffered writing (optional)
	writer := bufio.NewWriter(outputFile)
	defer writer.Flush()

	if addComment {
		_, err := writer.WriteString("// Code generated by mlflow/go/cmd/generate/main.go. DO NOT EDIT.\n\n")
		if err != nil {
			return fmt.Errorf("failed to add comment to generated file: %w", err)
		}
	}

	// Write the generated code to the file
	err = format.Node(writer, fset, file)
	if err != nil {
		return fmt.Errorf("failed to write generated AST to file: %w", err)
	}

	return nil
}

//nolint:funlen
func mkAppRoute(method discovery.MethodInfo, endpoint discovery.Endpoint) ast.Stmt {
	urlExpr := &ast.BasicLit{Kind: token.STRING, Value: fmt.Sprintf(`"%s"`, endpoint.GetFiberPath())}

	// input := &protos.SearchExperiments
	inputExpr := mkAssignStmt(
		[]ast.Expr{ast.NewIdent("input")},
		[]ast.Expr{
			mkAmpExpr(&ast.CompositeLit{
				Type: mkSelectorExpr(method.PackageName, method.Input),
			}),
		})

	// if err := parser.ParseQuery(ctx, input); err != nil { return err }
	// if err := parser.ParseBody(ctx, input); err != nil { return err }
	var extractModel ast.Expr
	if endpoint.Method == http.MethodGet {
		extractModel = mkCallExpr(mkSelectorExpr("parser", "ParseQuery"), ast.NewIdent("ctx"), ast.NewIdent("input"))
	} else {
		extractModel = mkCallExpr(mkSelectorExpr("parser", "ParseBody"), ast.NewIdent("ctx"), ast.NewIdent("input"))
	}

	inputErrorCheck := mkIfStmt(
		mkAssignStmt([]ast.Expr{ast.NewIdent("err")}, []ast.Expr{extractModel}),
		errNotEqualNil,
		mkBlockStmt(returnErr),
	)

	// output, err := service.Method(input)
	outputExpr := mkAssignStmt([]ast.Expr{
		ast.NewIdent("output"),
		ast.NewIdent("err"),
	}, []ast.Expr{
		mkCallExpr(
			mkSelectorExpr(
				"service",
				strcase.ToCamel(method.Name),
			),
			mkCallExpr(
				mkSelectorExpr("utils", "NewContextWithLoggerFromFiberContext"),
				ast.NewIdent("ctx"),
			),
			ast.NewIdent("input"),
		),
	})

	// if err != nil {
	//     return err
	// }
	errorCheck := mkIfStmt(
		nil,
		errNotEqualNil,
		mkBlockStmt(
			mkReturnStmt(ast.NewIdent("err")),
		),
	)

	// return ctx.JSON(output)
	returnExpr := mkReturnStmt(mkCallExpr(mkSelectorExpr("ctx", "JSON"), ast.NewIdent("output")))

	// func(ctx *fiber.Ctx) error { .. }
	funcExpr := &ast.FuncLit{
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					mkNamedField("ctx", mkStarExpr(mkSelectorExpr("fiber", "Ctx"))),
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					mkField(ast.NewIdent("error")),
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				inputExpr,
				inputErrorCheck,
				outputExpr,
				errorCheck,
				returnExpr,
			},
		},
	}

	return &ast.ExprStmt{
		// app.Get("/mlflow/experiments/search", func(ctx *fiber.Ctx) error { .. })
		X: mkCallExpr(
			mkSelectorExpr("app", strcase.ToCamel(endpoint.Method)), urlExpr, funcExpr,
		),
	}
}

func mkRouteRegistrationFunction(
	endpoints map[string]any, interfaceName string, serviceInfo discovery.ServiceInfo,
) *ast.FuncDecl {
	routes := make([]ast.Stmt, 0, len(serviceInfo.Methods))

	for _, method := range serviceInfo.Methods {
		for _, endpoint := range method.Endpoints {
			if _, ok := endpoints[method.Name]; ok {
				routes = append(routes, mkAppRoute(method, endpoint))
			}
		}
	}

	return &ast.FuncDecl{
		Name: ast.NewIdent(fmt.Sprintf("Register%sRoutes", interfaceName)),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					mkNamedField("service", mkSelectorExpr("service", interfaceName)),
					mkNamedField("parser", mkStarExpr(mkSelectorExpr("parser", "HTTPRequestParser"))),
					mkNamedField("app", mkStarExpr(ast.NewIdent("fiber.App"))),
				},
			},
		},
		Body: &ast.BlockStmt{
			List: routes,
		},
	}
}

func mkGeneratedFile(pkg, outputPath string, decls []ast.Decl) error {
	// Set up the FileSet and the AST File
	fset := token.NewFileSet()

	file := &ast.File{
		Name:  ast.NewIdent(pkg),
		Decls: decls,
	}

	err := saveASTToFile(fset, file, true, outputPath)
	if err != nil {
		return fmt.Errorf("failed to save AST to file: %w", err)
	}

	return nil
}

const expectedImportStatements = 2

// Generate the service interface.
func generateServices(
	pkgFolder string,
	serviceInfo discovery.ServiceInfo,
	generationInfo ServiceGenerationInfo,
	endpoints map[string]any,
) error {
	decls := make([]ast.Decl, 0, len(endpoints)+expectedImportStatements)

	if len(endpoints) > 0 {
		decls = append(decls,
			mkImportStatements(
				`"context"`,
				`"github.com/mlflow/mlflow-go/pkg/protos"`,
				`"github.com/mlflow/mlflow-go/pkg/contract"`,
			))
	}

	decls = append(decls, mkServiceInterfaceNode(
		endpoints,
		generationInfo.ServiceName,
		serviceInfo,
	))

	fileName := generationInfo.FileNameWithoutExtension + ".g.go"
	pkg := "service"
	outputPath := filepath.Join(pkgFolder, "contract", pkg, fileName)

	return mkGeneratedFile(pkg, outputPath, decls)
}

func generateRouteRegistrations(
	pkgFolder string,
	serviceInfo discovery.ServiceInfo,
	generationInfo ServiceGenerationInfo,
	endpoints map[string]any,
) error {
	importStatements := []string{
		`"github.com/gofiber/fiber/v2"`,
		`"github.com/mlflow/mlflow-go/pkg/server/parser"`,
		`"github.com/mlflow/mlflow-go/pkg/contract/service"`,
	}

	if len(endpoints) > 0 {
		importStatements = append(
			importStatements,
			`"github.com/mlflow/mlflow-go/pkg/utils"`,
			`"github.com/mlflow/mlflow-go/pkg/protos"`,
		)
	}

	decls := []ast.Decl{
		mkImportStatements(importStatements...),
		mkRouteRegistrationFunction(endpoints, generationInfo.ServiceName, serviceInfo),
	}

	fileName := generationInfo.FileNameWithoutExtension + ".g.go"
	pkg := "routes"
	outputPath := filepath.Join(pkgFolder, "server", pkg, fileName)

	return mkGeneratedFile(pkg, outputPath, decls)
}

func mkCEndpointBody(serviceName string, method discovery.MethodInfo) *ast.BlockStmt {
	mapName := strcase.ToLowerCamel(serviceName) + "s"

	return &ast.BlockStmt{
		List: []ast.Stmt{
			// service, err := trackingServices.Get(serviceID)
			mkAssignStmt(
				[]ast.Expr{
					ast.NewIdent("service"),
					ast.NewIdent("err"),
				},
				[]ast.Expr{
					mkCallExpr(mkSelectorExpr(mapName, "Get"), ast.NewIdent("serviceID")),
				},
			),
			// 	if err != nil {
			//		return makePointerFromError(err, responseSize)
			//  }
			mkIfStmt(
				nil,
				errNotEqualNil,
				mkBlockStmt(
					mkReturnStmt(
						mkCallExpr(
							ast.NewIdent("makePointerFromError"),
							ast.NewIdent("err"),
							ast.NewIdent("responseSize"),
						),
					),
				),
			),
			//	return invokeServiceMethod(
			// 		service.GetExperiment,
			//		new(protos.GetExperiment),
			// 		requestData,
			// 		requestSize,
			// 		responseSize,
			// 	)
			mkReturnStmt(
				mkCallExpr(
					ast.NewIdent("invokeServiceMethod"),
					mkSelectorExpr("service", strcase.ToCamel(method.Name)),
					mkCallExpr(ast.NewIdent("new"), mkSelectorExpr("protos", method.Input)),
					ast.NewIdent("requestData"),
					ast.NewIdent("requestSize"),
					ast.NewIdent("responseSize"),
				),
			),
		},
	}
}

func mkCEndpoint(serviceName string, method discovery.MethodInfo) *ast.FuncDecl {
	functionName := fmt.Sprintf("%s%s", serviceName, strcase.ToCamel(method.Name))

	return &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Text: "//export " + functionName,
				},
			},
		},
		Name: ast.NewIdent(functionName),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					mkNamedField("serviceID", ast.NewIdent("int64")),
					mkNamedField("requestData", mkSelectorExpr("unsafe", "Pointer")),
					mkNamedField("requestSize", mkSelectorExpr("C", "int")),
					mkNamedField("responseSize", mkStarExpr(mkSelectorExpr("C", "int"))),
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					mkField(mkSelectorExpr("unsafe", "Pointer")),
				},
			},
		},
		Body: mkCEndpointBody(serviceName, method),
	}
}

func mkCEndpoints(
	endpoints map[string]any, serviceName string, serviceInfo discovery.ServiceInfo,
) []*ast.FuncDecl {
	funcs := make([]*ast.FuncDecl, 0, len(endpoints))

	for _, method := range serviceInfo.Methods {
		if _, ok := endpoints[method.Name]; ok {
			funcs = append(funcs, mkCEndpoint(serviceName, method))
		}
	}

	return funcs
}

func generateEndpoints(
	pkgFolder string,
	serviceInfo discovery.ServiceInfo,
	generationInfo ServiceGenerationInfo,
	endpoints map[string]any,
) error {
	decls := []ast.Decl{
		mkImportStatements(`"C"`),
	}

	if len(endpoints) > 0 {
		decls = append(
			decls,
			mkImportStatements(
				`"unsafe"`,
				`"github.com/mlflow/mlflow-go/pkg/protos"`,
			),
		)

		endpoints := mkCEndpoints(endpoints, generationInfo.ServiceName, serviceInfo)
		for _, endpoint := range endpoints {
			decls = append(decls, endpoint)
		}
	}

	fileName := generationInfo.FileNameWithoutExtension + ".g.go"
	outputPath := filepath.Join(pkgFolder, "lib", fileName)

	return mkGeneratedFile("main", outputPath, decls)
}

func SourceCode(pkgFolder string) error {
	services, err := discovery.GetServiceInfos()
	if err != nil {
		return fmt.Errorf("failed to get service info: %w", err)
	}

	for _, serviceInfo := range services {
		generationInfo, ok := ServiceInfoMap[serviceInfo.Name]
		if !ok {
			continue
		}

		endpoints := make(map[string]any, len(generationInfo.ImplementedEndpoints))

		for _, endpoint := range generationInfo.ImplementedEndpoints {
			endpoints[endpoint] = nil
		}

		err = generateServices(pkgFolder, serviceInfo, generationInfo, endpoints)
		if err != nil {
			return err
		}

		err = generateRouteRegistrations(pkgFolder, serviceInfo, generationInfo, endpoints)
		if err != nil {
			return err
		}

		err = generateEndpoints(pkgFolder, serviceInfo, generationInfo, endpoints)
		if err != nil {
			return err
		}
	}

	return nil
}
